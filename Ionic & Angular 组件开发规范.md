一般情况下，如若是涉及到通用的交互行为与视图结构，**在遇到2个页面以上的复用时，就应该进行封装一个新的Component**。
涉及的代码量比较多的时候，也应该进行封装。因为理论上，一个Class，应该专注处理一件事情，专注维护一组数据与状态。一个View Class也不例外，当View Class中出现要管理多组数据的时候，这时候就应该切分成多个Class，如果某组数据正好是针对一个区域的视图，就是要封装一个Component的时候。**有时候，我们封装Component，不是为了复用，而是考虑代码的可维护性**，动画组件就是属于这一类。

> 注意：如果只是视图级别的重复，一般不需要封装组件，只要保持一致的书写风格，复用CSS即可。比如列表，只需要在src/app文件夹下写一个通用的common-list.scss来统一修饰这些列表就好了。**避免过度封装**。



### 功能组件

这里用**点击获取验证码**的按钮这个例子来的重点来做说明。基础状态流程：

1. 绑定点击事件，触发验证码发送函数

2. 按钮进入发送中状态

3. 验证码已经发送并开始倒计时

4. 倒计时完成再次进入可用状态

根据以上流程，在 2 、3 的状态中，按钮是不可用的，这个时候应该对组件进行样式级别的变动。在正常开发环境下，我们可能根本不会看到 2 的这个状态。但**我们可以通过chrome dev tool来模拟3g网络或者离线状态。每个涉及到网络交互级别的组件开发都要做如此的考虑。**如果 2 发生异常，则返回到 1 之前，重新让按钮可点击，并告知用户异常情况。



接下来要考虑的就是组件、页面、应用生命周期与这个倒计时的关系了。

前端开发者要考虑的是，当用户销毁组件并重新创建组件时，倒计时是否需要继续进行（多数情况下是要的），当用户更换手机或者邮箱时，倒计时是否也要进行（一般情况下也是要的）。

所以多数情况下，开发者需要根据需求（可能涉及到后端返回的约束，比如黑名单禁闭），来将这个组件涉及到的数据存储到本地而不是内存，以**确保组件销毁并重新生成的时候，还能处于一个正确的状态**。

再有，这些本地存储的数据要做及时的清理（比如在应用启动时检查时间戳，或者频繁地在组件创建的时候进行一次清理），避免过期数据撑爆应用，这类数据应该使用localstroge这样的同步存储，**避免异步带来的不便利与复杂度提升**。

实现以上基础功能后，再根据用户体验与需求做拓展，比如自动发送验证码，自定义字段与样式名等等。



第二个例子是**动画组件**

这里我不针对某个例子来。我就说一下我的开发方式。

首先使[parcel](https://parceljs.org)工具，创建一个单独的pixijs项目，基于typescript，因为angular编译很慢，所以使用[parcel](https://parceljs.org)只需要编译ts，做原型开发就很快。（PS：在这种快速原型开发中，ts反而会比js优秀很多，因为基于类型提示，我们能确保小bug被快速规避，智能的代码提示也能极速提升编码速率，pixijs与threejs都有相关的types定义）

动画基础知识我就不进行赘述，我就谈一些动画要考虑的东西。

最重要的就是初始化。**第一步就是资源加载**。这个必须放在全局，要优化的话顶多就加一个按需懒加载。资源加载完后就是初始化画布程序动画组件应该与pixi解耦，所以**应该禁用pixi或者其它框架的自动启用raf进行轮询，转而自己控制动画的渲染时机**。

这样的话，可以针对不同的动画类型，做按需渲染。以及降低帧率。比如 IBT2 中，动态的阳光动画，我就通过配置跳帧，将动画降低到15帧，因为这里动画很慢，低帧率的情况下用户也不会有掉帧的感知。还有掉金币的动画，设计上来说是一堆堆的金币，所以在金币掉下后，那堆金币就可以缓存成静态的图片，只需要在金币掉入的那堆开启动态绘制即可。在金币掉入完成后，即可停止动画。等到下一次要掉落金币的时候再做开启。

由于多个金币动画都在竞争管理一个动画是否开启动画的状态机。我的实现方式使用Set来进行管理，每个金币都有一个id，将这个id加入或者移出set对象，最后是否开启动画的这个状态机就由set.size进行管理。
```ts
class AniBase{
// ...
  private _force_update_set = new Set<string | number>();
  upForceUpdate(key: string | number) {
    const { _force_update_set } = this;
    _force_update_set.add(key);
    this.force_update = !!_force_update_set.size;
  }
  downForceUpdate(key: string | number) {
    const { _force_update_set } = this;
    _force_update_set.delete(key);
    this.force_update = !!_force_update_set.size;
  }
// ...
}
```

初始化完后，**第二步要考虑的就是传入配置参数了**。

这里有一个规范就是复杂的参数模型（Object类型的参数），不应该使用赋值的方式来变更参数，而应该使用`Object.assgn()`或者`属性展开`这样的方式来处理复杂参数。这样才能确保组件升级的时候，只需要改动默认参数就能确保组件正常的运作。
```ts
class ExampleComponent{
  @Input("some-input-param")
  set config(v) {
    this._config = Object.assign(this._config, v);
  }
  private _config = { ...this.default_config };
  get config() {
    return this._config;
  }
}
```
> PS: `@Input`修饰器后面一般是跟set。语法解析上来说跟get与set没差，只是基于可读性优先的情况下，set会是更好的选择。

